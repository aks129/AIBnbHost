import express from 'express';
import { z } from 'zod';
import { storage } from '../server/storage.js';
import { analyzeMessageIntent, generateAutoReply, shouldAutoReply } from '../server/services/auto-reply.js';
import { randomUUID } from 'crypto';

const router = express.Router();

// In-memory storage for conversations and messages (in production, use database)
const conversations = new Map<string, any>();
const messagesByConversation = new Map<string, any[]>();

// Seed some sample conversations
const seedConversations = () => {
  if (conversations.size === 0) {
    const conv1 = {
      id: 'conv-1',
      guestName: 'Sarah Johnson',
      guestEmail: 'sarah.j@example.com',
      propertyName: 'Cozy Downtown Apartment',
      lastMessage: 'Hi! What time is check-in?',
      lastMessageTime: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
      unreadCount: 1,
      status: 'active',
      intent: {
        category: 'question',
        urgency: 'low',
        requiresHostAttention: false,
      },
    };

    const conv2 = {
      id: 'conv-2',
      guestName: 'Michael Chen',
      guestEmail: 'mchen@example.com',
      propertyName: 'Cozy Downtown Apartment',
      lastMessage: 'The WiFi isn\'t working. Can you help?',
      lastMessageTime: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
      unreadCount: 1,
      status: 'active',
      intent: {
        category: 'request',
        urgency: 'medium',
        requiresHostAttention: true,
      },
    };

    conversations.set(conv1.id, conv1);
    conversations.set(conv2.id, conv2);

    // Seed messages
    messagesByConversation.set('conv-1', [
      {
        id: 'msg-1',
        conversationId: 'conv-1',
        sender: 'guest',
        content: 'Hi! What time is check-in?',
        timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
      },
    ]);

    messagesByConversation.set('conv-2', [
      {
        id: 'msg-2',
        conversationId: 'conv-2',
        sender: 'guest',
        content: 'The WiFi isn\'t working. Can you help?',
        timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
      },
    ]);
  }
};

// Get all conversations
router.get('/', async (req, res) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    seedConversations();
    const allConversations = Array.from(conversations.values());
    res.json(allConversations);
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ error: 'Failed to fetch conversations' });
  }
});

// Get messages for a conversation
router.get('/:conversationId/messages', async (req, res) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const messages = messagesByConversation.get(req.params.conversationId) || [];
    res.json(messages);
  } catch (error) {
    console.error('Error fetching messages:', error);
    res.status(500).json({ error: 'Failed to fetch messages' });
  }
});

// Send a message
router.post('/:conversationId/messages', async (req, res) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const { content, useAI } = req.body;
    if (!content) {
      return res.status(400).json({ error: 'Message content is required' });
    }

    const conversation = conversations.get(req.params.conversationId);
    if (!conversation) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const newMessage = {
      id: randomUUID(),
      conversationId: req.params.conversationId,
      sender: useAI ? 'ai' : 'host',
      content,
      timestamp: new Date().toISOString(),
      isAutoGenerated: useAI || false,
    };

    const messages = messagesByConversation.get(req.params.conversationId) || [];
    messages.push(newMessage);
    messagesByConversation.set(req.params.conversationId, messages);

    // Update conversation
    conversation.lastMessage = content;
    conversation.lastMessageTime = newMessage.timestamp;
    conversation.unreadCount = 0;
    conversations.set(req.params.conversationId, conversation);

    res.json(newMessage);
  } catch (error) {
    console.error('Error sending message:', error);
    res.status(500).json({ error: 'Failed to send message' });
  }
});

// Generate AI reply for a conversation
router.post('/:conversationId/generate-reply', async (req, res) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const conversation = conversations.get(req.params.conversationId);
    if (!conversation) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const messages = messagesByConversation.get(req.params.conversationId) || [];
    const lastGuestMessage = messages.filter(m => m.sender === 'guest').pop();

    if (!lastGuestMessage) {
      return res.status(400).json({ error: 'No guest message to reply to' });
    }

    // Build conversation history for context
    const conversationHistory = messages.slice(-5).map(m => ({
      role: m.sender === 'guest' ? 'user' as const : 'assistant' as const,
      content: m.content,
    }));

    const reply = await generateAutoReply({
      guestName: conversation.guestName,
      guestMessage: lastGuestMessage.content,
      propertyName: conversation.propertyName,
      conversationHistory,
    });

    res.json({ reply });
  } catch (error) {
    console.error('Error generating AI reply:', error);
    res.status(500).json({ error: 'Failed to generate reply' });
  }
});

// Analyze message intent
router.post('/analyze-intent', async (req, res) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const { message } = req.body;
    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }

    const intent = await analyzeMessageIntent(message);
    res.json(intent);
  } catch (error) {
    console.error('Error analyzing intent:', error);
    res.status(500).json({ error: 'Failed to analyze intent' });
  }
});

export default router;
